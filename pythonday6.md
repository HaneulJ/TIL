## 1/11 수업

#### 파이썬의 내장 자료구조

> 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법

* 시퀀스형(문자열, tuple, list): 저장된 순서유지(indexing, slicing, unpacking)

* 매핑형(dictionary): 보관되는 값마다 일일히 이름을 줘서 name-value쌍으로 기억

* 집합형(set): 중복 데이터 저장 불가, 집합연산 적용가능



##### 파이썬의 인수 활용방법:(1)일반 인수, (2)가변 인수, (3)키워드 가변인수



### 인수의 형식

#### 가변인수

* 가변인수: 인수 목록의 마지막에 하나만 가능
* 0개 이상의 positional argument 전달 가능

```
>>> intsum(s, *ints)		# 가능
>>> intsum(*ints, s)		# 에러
>>> intsum(*ints, *nums)	# 에러
```



#### 인수의 기본값

* 잘 바뀌지 않는 인수는 인수 목록에 기본값 지정
  * 실인수 생략하면 기본값 전달로 가정



#### 키워드 인수

> 인수 이름을 지정하여 대입 형태로 전달하는 방식

* 앞쪽에 키워드 인수가 있으면 뒤쪽에 위치인수 올 수 없음
* 기본값을 갖는 인수가 있으면 위치인수 뒤쪽에 작성 가능



#### 키워드 가변인수

> ***기호* 를 인수 목록에 붙여 키워드 인수를 가변 개수 전달

* 위치인수와 키워드 인수를 동시에 가변으로 취할 수  있음
* 0개 이상의 keyword argument 전달 가능(이름이 있어야 함)





### Dictionary 딕셔너리

#### dictionary

> 전화번호부와 같이 키(key)와 값(value)형태로 데이터 저장

* 딕셔너리 변수: {키1:값1, 키2:값2, 키3:값3,... }
* key는 중복 X
* 같은 key값을 같는 마지막 데이터가 호출
* 특정 값을 호출하는 방법: 해당 값의 키를 대괄호[]안에 넣어 호출할 수 있다.

```
>>> student_info[20140012]
'Sungchul'
```

* 재할당과 데이터 추가 가능
* 딕셔너리의 내용을 얻기 위해서는 **`items()`, `key()`, `value()`** 메소드 사용
* `item()`: 딕셔너리의 모든 키와 값을 tuple로 묶어서 반환
* `key()`: key만 반환, 정렬이 안된 상태라 색인으로 value선택 불가
  * 변경이 불가능한 자료형들 **int, float, tuple, str()**으로만 만들어짐
  * key로 검색해서 읽기 위해 유일성을 유지해야 하므로 키를 생성할 때 `hash` 알고리즘을 통해 유일한 값만 구성해준다.
* `values()`: 값만 반환
* 딕셔너리 자체는 for문에 사용할 수 없으나 메소드를 사용하면 가능
* `dict(name1=value1, name2=value2, ...)`

* `dic.get()`: dictionary에 소속된 함수
* `dictionary = {}`

```
>>> print(list(item))
[('a':'10'),('b','20')]
# 튜플 형식으로 출력됌
```

```
>>> item = x.item()

>>> for key, value in item:
        if value == 20:
            del x[key]
error
# item은 iterable불가
# iterable이란 하나씩 값을 순서대로 빼오는 것

>>> for key, value in list(item):
       if value == 20:
           del x[key]
>>> print(x)
('a':'10','c':'30','d':'40')
# dic에 변경을 하고 싶을 때는 list(item)으로!
```



for ~ in ** : *에 쓸 수 있는 것은 iterable하다!



### Set 집합

> 순서는 없고 중복되지 않는 여러 개의 데이터를 담는 상자

* set는 튜플과 다르게 삭제나 변경이 가능하며, 다양한 집합 연산(교집합, 합집합)을 제공한다.
* 값은 버리고 **key**만 남은 dictionary와 같다.
* set는 list와 마찬가지로 값들의 모임이며, index사용 불가
* set 생성: `set()` list, tuple, 문자열 등의 하나의 데이터셋만 지정 가능
  * 중괄호{}안에 콤마로 구분된 하나의 데이터 값 지정 가능
* dictionary에 `set()`을 사용하여 key만 사용
* 빈 세트형은 반드시 `set()`함수로만 가능

```
# 집합 연산
>>> s1 = set([1, 2, 3, 4, 5, 6])
>>>> s2 = set([4, 5, 6, 7, 8, 9])
>>> print(s1, s2)
>>> print('intersect - ', s1 & s2) 		# &: 교집합 
>>> print('union - ', s1 | s2)			# |: 합집합
>>> print('difference - ', s1 - s2)		# -: 차집합
>>> print('exclusive - ', s1 ^ s2)		# ^: 각자 가지고 있는 값만의 합 

{1, 2, 3, 4, 5, 6} {4, 5, 6, 7, 8, 9}
intersect -  {4, 5, 6}
union -  {1, 2, 3, 4, 5, 6, 7, 8, 9}
difference -  {1, 2, 3}
exclusive -  {1, 2, 3, 7, 8, 9}
```

```
>>> s1 = set()
>>> s1.add(10);s1.add(20);s1.add(30);s1.add(40);s1.add(50)
>>> print('s1(10,20,30,40,50추가) - ', s1)
# 순서X, 중복X
s1(10,20,30,40,50추가) -  {40, 10, 50, 20, 30}

>>> s1.add(10)
>>> print('s1(10추가실패) - ', s1)
s1(10추가실패) -  {40, 10, 50, 20, 30}
# list와 다른 점: 순서유지X 중복값 추가X

>>> s1.update([40,50,60,70])
>>> print('s1(40,50,60,70변경) - ', s1)
s1(40,50,60,70변경) -  {70, 40, 10, 50, 20, 60, 30}
# 중복되는 값은 제외

>>> s1.remove(30)
>>> print('s1(30삭제) - ', s1)
s1(30삭제) -  {70, 40, 10, 50, 20, 60}

>>> print('length -', len(s1))
length -  6
```





### 함수정리

#### 변수의 사용 범위 scope

* 변수의 사용 변위(scoping rule): 변수가 코드에서 사용되는 범위
* 지역 변수(local variable): 함수 안에서만 사용
* 전역 변수(global variable): 프로그램 전체에서 사용

